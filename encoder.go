package gotiny

import (
	"reflect"
	"unsafe"
)

// Encoder keeps data needed for encoding
// Keep in mind that one Encoder is not ment to be used in different goroutines, use Scheme for this case
type Encoder struct {
	buf     []byte //Enoding destination array
	off     int
	boolPos int  // The next time you want to set the subscript of bool in buf, buf[boolPos]
	boolBit byte // The bit in the buf[boolPos] of the bool to be set next time.

	engines []encEng
	length  int
}

// Marshal instantly encodes any object by pointer to byte array
// For performance recommended to create schema first using gotiny.New
func Marshal(is ...interface{}) []byte {
	return NewEncoderWithPtr(is...).Encode(is...)
}

// NewEncoderWithPtr creates an encoder that encodes the ps pointing type
func NewEncoderWithPtr(ps ...interface{}) *Encoder {
	return NewWithPtr(ps...).GetEncoder()
}

// NewEncoder creates an encoder with the encoding is type
func NewEncoder(is ...interface{}) *Encoder {
	return New(is...).GetEncoder()
}

// NewEncoderWithType creates encoder using reflect.Type
func NewEncoderWithType(ts ...reflect.Type) *Encoder {
	return NewWithType(ts...).GetEncoder()
}

// Encode object using entry parameter as a pointer to the value to be encoded
func (e *Encoder) Encode(is ...interface{}) []byte {
	engines := e.engines
	for i := 0; i < len(engines) && i < len(is); i++ {
		engines[i](e, (*[2]unsafe.Pointer)(unsafe.Pointer(&is[i]))[1])
	}
	return e.reset()
}

// EncodePtr the input parameter is the unsafe.Pointer pointer
func (e *Encoder) EncodePtr(ps ...unsafe.Pointer) []byte {
	engines := e.engines
	for i := 0; i < len(engines) && i < len(ps); i++ {
		engines[i](e, ps[i])
	}
	return e.reset()
}

// EncodeValue the input parameter is the reflect.Value
func (e *Encoder) EncodeValue(vs ...reflect.Value) []byte {
	engines := e.engines
	for i := 0; i < len(engines) && i < len(vs); i++ {
		engines[i](e, getUnsafePointer(&vs[i]))
	}
	return e.reset()
}

// AppendTo the data generated by the encoding will be append to buf
func (e *Encoder) AppendTo(buf []byte) {
	e.off = len(buf)
	e.buf = buf
}

func (e *Encoder) reset() []byte {
	buf := e.buf
	e.buf = buf[:e.off]
	e.boolBit = 0
	e.boolPos = 0
	return buf
}
